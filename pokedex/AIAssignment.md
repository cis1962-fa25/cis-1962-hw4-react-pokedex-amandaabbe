# Homework 4 AI Synthesis Activity

Only complete one of the assignments below! You can delete the other assignment in this document once you've made your choice.

## Activity: You used AI

### Part 1

> Cite the usage by including screenshots, a text transcript, or a link to the conversation with your AI of choice. Make sure to include any context, instructions, and all the conversations you had with the AI.

### Part 2

> Write about why you used AI. Was there a gap in knowledge you wanted to fill? Were the answers through traditional search engines not adequate? Did you want to let AI help you format something in a quick manner?

### Part 3

> Evaluate the AI's response. If you asked multiple questions, you can pick one of the responses the AI generated. Does the AI answer your question properly? Does it hallucinate any details? Could there be room to improve this response through manual editing? Did you accept this response fully or adapt parts of it into your work?

### Part 4

> If you used unfamiliar syntax or concepts generated by AI within your assignment, be sure to research them and explain what those concepts are to demonstrate your understanding.

---

## Activity B: You did NOT use AI

### Part 1

> Explain some improvement you want to make within your code. Perhaps you have a code block that could be more concise, or a part of your code could be improved with a library or be performed with a more efficient algorithm.

One improvement I would like to make in my code is how I handle loading and displaying Box entries in App.tsx. Right now, whenever I switch to the “My Box” view, I call listBoxIds() and then getBoxEntry(id) for every ID, and I reload the entire list after every edit or delete. This works, but it’s a bit inefficient and tightly coupled to the UI. A more polished approach might be to extract the Box-loading logic into a custom hook (e.g. useBoxEntries) or a separate module, cache results so I don’t always re-fetch on every view switch, and possibly improve the way errors and loading states are handled (for example, per-entry or with retries), instead of one single boxError / boxLoading state in App.tsx.

### Part 2

> Ask AI how to improve your code, by picking a part of your program you are interested in improving and asking something along the lines of "how can I improve this code?" This does not have to be verbatim; you could ask more specific questions for improvement, like "what JavaScript libraries could improve the efficiency of my code?" Screenshot or link the response.

My prompt: 

I have a React + TypeScript Pokedex app that uses a backend Box API. In App.tsx, whenever the user switches to the ‘My Box’ view, I call listBoxIds() and then getBoxEntry(id) for each ID, and I store everything in a boxEntries state. I also reload all Box entries after every edit and delete. Here is the relevant part of my App.tsx (then I inserted the relevant part of my code) How can I improve this? Are there cleaner patterns for managing this Box data, avoiding unnecessary refetches, or organizing this logic (like hooks, context, or caching)?”

The AI's response:

There are several improvements you can make to your Box-fetching logic to make it more efficient, maintainable, and better organized within a React + TypeScript application. Right now, your App.tsx handles all the data fetching, status tracking, and refreshing. While this works, it mixes together concerns (view state, modals, and API logic). Below are a few suggestions:
1. Extract Box logic into a custom hook
Creating a hook such as useBoxEntries() would let you isolate:
boxEntries
boxLoading
boxError
loadBoxEntries (renamed to reloadBoxEntries)
Example structure:
export function useBoxEntries() {
  const [entries, setEntries] = useState<BoxEntry[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const reload = async () => {
    try {
      setLoading(true);
      setError(null);

      const ids = await listBoxIds();
      const fullEntries = await Promise.all(ids.map(id => getBoxEntry(id)));
      setEntries(fullEntries);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load Box.");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    reload();
  }, []);

  return { entries, loading, error, reload };
}
In App.tsx, you then consume it:
const { entries, loading, error, reload } = useBoxEntries();
This significantly simplifies App.tsx and keeps API/data logic in one place.
2. Avoid re-fetching Box data every time the user switches views
Instead of tying loadBoxEntries() to:
useEffect(() => {
  if (view === "box") loadBoxEntries();
}, [view]);
you could:
fetch once on first mount
manually call reload() only after a mutation (create/update/delete)
This prevents unnecessary requests when toggling between “My Box” and “All Pokémon.”
3. Optional: use React context if Box data is needed across multiple components
If you ever expand the app (e.g., a dedicated Box page), you can wrap the app in a BoxProvider that exposes:
entries
update/delete functions
a global reload function
This avoids prop-drilling, though it may be more architectural than you need for a small assignment.
4. Add caching or memoization to avoid repeated API calls
For example:
Use useRef or memoized values to store the last-fetched Box entries
Only re-fetch if entries are stale or explicitly refreshed
This can reduce load time and API usage.
Summary
Your current code is correct, but reorganizing the Box data flow into a custom hook is the most impactful improvement. It will:
simplify App.tsx
centralize Box logic
allow controlled refreshing
reduce unnecessary API calls
The context and caching suggestions are optional but become beneficial as the app grows.

### Part 3

> Evaluate the response the AI generates. You may need to do some research to do this evaluation, to see if the syntax generates correctly or if any libraries the AI suggests are appropriate for the current task. Report on whether the AI's solution fits within your project, or if it would need modifications to work properly.

The AI’s suggestions are mostly accurate and would work with my current code. The idea of moving the Box-loading logic into a custom hook (useBoxEntries) is valid, and the example code it gave is syntactically correct TypeScript/React. This would clean up App.tsx and make the Box fetching more organized. The AI also suggested avoiding re-fetching Box data every time the user switches views. That is true, as my current useEffect refetches on every toggle, and using a manual reload() function instead would be more efficient. The other recommendations, like using React context or caching, are technically correct but unnecessary for a small homework project. They would add more structure than I need. All in all, the AI’s response is reasonable, and the improvements would work, but only the custom hook and reduced refetching would be practical for this assignment.

**_ You do NOT need to use the AI suggestion within your final submission, if your code already works properly. If the scope of your inquiry in this activity leads you to replace parts of your code, switch to the other version of this activity instead. _**
